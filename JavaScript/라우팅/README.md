# 자바스크립트에서의 라우팅

## SPA

- SPA란, 단일 페이지 애플리케이션으로, 기본적으로 단일 페이지로 구성되며 기존의 서버 사이드 렌더링과 비교할 때, 배포가 간단하며 네이티브 앱과 유사한 사용자 경험을 제공할 수 있다는 장점이 있다.
- 기본적으로 웹 애플리케이션에 필요한 모든 정적 리소스를 최초 한번만 다운로드한다. 이후 새로운 페이지 요청 시, 페이지 갱신에 필요한 데이터만을 전달받아 페이지를 갱신하므로 전체적인 트래픽을 감소할 수 있다. 또한 전체 페이지가 다시 렌더링 되는 것이 아니라, 변경된 부분만 갱신하므로 새로고침이 발생하지 않아 <italic>사용자 경험</italic> 개선에 도움이 된다.
- SPA에도 단점이 존재!!
  > ### 초기 구동 속도
  >
  > SPA는 최초에 필요한 모든 정적 리소스를 다운로드하기 때문에 초기 구동 속도가 상대적으로 느리다. SPA는 웹페이지보다는 애플리케이션에 적합한 기술이다. 그렇기 때문에 트래픽의 감소와 속도, 사용성, 반응성의 향상 등의 장점을 생각한다면 결정적인 단점이라고 할 수는 없다.
  >
  > ### SEO(검색엔진 최적화) 문제
  >
  > SPA는 클라이언트 렌더링 방식에 기반한다. 이에 따라 SPA에서는 SEO 문제가 존재한다. 그러나 자바스크립트 라이브러리 혹은 프레임워크에서는 서버 사이드 렌더링을 지원하는 방안도 있고, 부분적으로 SEO를 적용할 수 있는 방안도 있다.

## 라우팅

- 라우팅이란 출발지에서 목적지까지의 경로를 결정하는 기능이다. 애플리케이션에서의 라우팅은 사용자가 화면을 전환하는 내비게이션을 관리하기 위한 기능을 의미한다.
- 화면을 전환하는 경우
  1. 브라우저의 주소창에 URL을 입력하면 해당 페이지로 이동한다.
  2. 웹페이지의 링크를 클릭하면 해당 페이지로 이동한다.
  3. 브라우저의 뒤로가기 또는 앞으로가기 버튼을 클릭하면 사용자가 방문한 웹페이지의 기록(history)의 뒤 또는 앞으로 이동한다.
- history 관리를 위해서는 각 페이지는 브라우저의 주소창에서 구별할 수 있는 유일한 URL을 소유하여야 한다.

## 방법

### 1. 전통적 링크 방식

- 단순한 link tag로 동작한다.
- a 태그의 href 값인 리소스의 경로가 URL의 path에 추가되어 주소창에 나타나고, 해당 리소스를 서버에 요청한다. 그러면 서버에서는 해당 리소스 파일을 클라이언트에 전달해준다. 파일을 받은 클라이언트는 해당 파일을 렌더링한다. 이때, html 페이지 전체를 전환하므로 새로고침이 발생한다.

  ### 특징

  1. 해당 방식은 JavaScript를 사용하지 않고, response로 온 html만으로 렌더링이 가능하며 각 페이지마다 고유의 URL이 존재하기 때문에, history 관리와 SEO 대응이 가능하다.
  2. 중복된 리소스를 요청마다 수신해야 하며, 전체 페이지를 다시 렌더링하는 과정에서 새로고침이 발생하여 사용자 경험에 좋지 않다.

### 2. Ajax 방식

- JavaScript를 이용해서 비동기적으로 서버와 브라우저가 데이터를 교환할 수 있다.

  ### 특징

  1. 페이지 일부만 갱신하여 새로 고침이 없다. -> 사용자 경험 개선
  2. Ajax는 URL을 변경시키지 않기 때문에, 주소창의 주소가 변하지 않는다. -> history 관리가 되지 않는다. 따라서 새로고침을 클릭하면 항상 첫페이지가 로딩 된다.
  3. 하나의 주소로 동작하기 때문에, SEO 문제가 있다.

### 3. Hash 방식

- Ajax는 불필요한 리소스 중복 요청을 방지할 수 있고, 새로고침이 없는 사용자 경험을 구현할 수 있다는 장점이 있지만, history 관리가 되지 않는다. 이를 보완하는 것이 Hash 방식이다.
- a 태그의 href에 hash(#)를 사용한다.
- window의 hashchange 이벤트를 사용하여, uri의 hash가 변경하면 서버에 요청하는 함수를 실행한다.
- window의 DOMContentLoaded 이벤트를 통해, 초기 HTML 파일을 완전히 불러오고 분석했을 때 서버에 요청하는 함수를 실행한다. (load 이벤트보다 먼저 발생한다.)

  ### 특징

  1. URL이 동일한 상태에서 hash가 변경되면 서버에 어떠한 요청도 보내지 않는다. -> 페이지가 갱신되지 않는다. hash는 요청을 위한 것이 아니라 fragment identifier(ex, #service)의 고유 기능인 앵커로 웹페이지 내부에서 이동을 위한 것이다.
  2. hash는 URL이 존재하기 때문에 history 관리가 가능하다.
  3. uri에 불필요한 #이 들어가는 단점이 있다.
  4. SEO 이슈와 웹 크롤러에 반응하지 않는다.

### 4. Pjax 방식

- hash 방식의 가장 큰 단점은 SEO 이슈이다. 이를 보완하기 위해 History API인 pushState와 popState를 사용한다. (대부분의 브라우저에서 작동한다.)

## 라우팅 관련 이벤트

1. pushState
   > history.pushState(state, title, url);

- state: state를 넘겨준다. 현재 페이지에서 다른 페이지로 넘어갈때 가져갈 state (객체값)
- title: 새로운 history의 제목을 제공, 현재 적용이 안되기 때문에, null로 넣어주는 것이 좋다.
- url(optional): 해당 url로 홈페이지의 uri를 변경한다.

2. popstate
   > window.addEventListener('popstate', function);

- 뒤로가기 이벤트를 감지하여 처리한다.

```javascript
window.addEventListener("popstate", (e) => {
  // 리렌더링
});
```

## 코드 레퍼런스

- https://kdydesign.github.io/2020/10/06/spa-route-tutorial/
- https://velog.io/@seeh_h/VanilaJS%EB%A1%9C-SPA-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0
- https://github.com/Siihyun/CODEV21-FRONT
